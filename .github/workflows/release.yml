name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Release version (e.g. 1.0.0)"
        required: true
        type: string

jobs:
  build:
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            artifact-name: release-macos
          - os: windows-latest
            artifact-name: release-windows
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: |
            app/package-lock.json
            app/sidecar/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "app/src-tauri -> target"

      - name: Install npm dependencies
        working-directory: app
        run: npm ci

      - name: Install sidecar dependencies
        working-directory: app/sidecar
        run: npm ci

      - name: Build sidecar
        working-directory: app/sidecar
        run: node build.js

      - name: Stamp version into config files
        working-directory: app
        shell: bash
        env:
          RELEASE_VERSION: ${{ inputs.version }}
        run: |
          # Tauri config only accepts X.Y.Z — strip any pre-release suffix (e.g. 0.9.7-rc1 → 0.9.7)
          TAURI_VERSION="${RELEASE_VERSION%%-*}"
          export TAURI_VERSION
          node -e "const fs=require('fs'); const f='src-tauri/tauri.conf.json'; const c=JSON.parse(fs.readFileSync(f,'utf8')); c.version=process.env.TAURI_VERSION; fs.writeFileSync(f,JSON.stringify(c,null,2)+'\n');"
          node -e "const fs=require('fs'); const f='package.json'; const c=JSON.parse(fs.readFileSync(f,'utf8')); c.version=process.env.RELEASE_VERSION; fs.writeFileSync(f,JSON.stringify(c,null,2)+'\n');"
          sed -i.bak "s/^version = \".*\"/version = \"${RELEASE_VERSION}\"/" src-tauri/Cargo.toml && rm -f src-tauri/Cargo.toml.bak

      - name: Cache bundled Node.js binary
        id: node-cache
        uses: actions/cache@v4
        with:
          path: app/src-tauri/resources/node
          key: bundled-node-v22.14.0-${{ matrix.os }}

      # Bundle Node.js 22 LTS binary into the app so it works on clean machines
      # without Node.js installed. Adds ~40-70MB to the app package size.
      # macOS: downloads the official Node.js tar.gz and extracts just the `node` binary.
      # Windows: downloads the official Node.js zip and extracts `node.exe`.
      - name: Bundle Node.js 22 LTS binary (macOS)
        if: matrix.os == 'macos-latest' && steps.node-cache.outputs.cache-hit != 'true'
        shell: bash
        run: |
          set -euo pipefail
          NODE_VERSION="v22.14.0"

          # Detect runner architecture → Node.js platform string
          RUNNER_ARCH="$(uname -m)"
          if [ "$RUNNER_ARCH" = "arm64" ]; then
            NODE_ARCH="darwin-arm64"
          else
            NODE_ARCH="darwin-x64"
          fi

          DEST="app/src-tauri/resources/node/${NODE_ARCH}/bin"
          mkdir -p "$DEST"

          TARBALL="node-${NODE_VERSION}-${NODE_ARCH}.tar.gz"
          URL="https://nodejs.org/dist/${NODE_VERSION}/${TARBALL}"

          echo "Downloading Node.js ${NODE_VERSION} for ${NODE_ARCH}..."
          curl -fsSL "$URL" -o "/tmp/${TARBALL}"

          echo "Verifying SHA256 checksum..."
          curl -fsSL "https://nodejs.org/dist/${NODE_VERSION}/SHASUMS256.txt" -o "/tmp/SHASUMS256.txt"
          (cd /tmp && grep "${TARBALL}" SHASUMS256.txt | shasum -a 256 -c -)

          echo "Extracting node binary..."
          tar -xzf "/tmp/${TARBALL}" -C /tmp "node-${NODE_VERSION}-${NODE_ARCH}/bin/node"
          mv "/tmp/node-${NODE_VERSION}-${NODE_ARCH}/bin/node" "${DEST}/node"
          chmod +x "${DEST}/node"

          # Verify the binary works
          "${DEST}/node" --version

          # Report size for documentation
          NODE_SIZE=$(du -sh "${DEST}/node" | cut -f1)
          echo "Bundled node binary size: ${NODE_SIZE}"

          # Cleanup
          rm -rf "/tmp/${TARBALL}" "/tmp/node-${NODE_VERSION}-${NODE_ARCH}"

      - name: Bundle Node.js 22 LTS binary (Windows)
        if: matrix.os == 'windows-latest' && steps.node-cache.outputs.cache-hit != 'true'
        shell: bash
        run: |
          set -euo pipefail
          NODE_VERSION="v22.14.0"
          NODE_ARCH="win-x64"

          DEST="app/src-tauri/resources/node/${NODE_ARCH}/bin"
          mkdir -p "$DEST"

          ZIPFILE="node-${NODE_VERSION}-${NODE_ARCH}.zip"
          URL="https://nodejs.org/dist/${NODE_VERSION}/${ZIPFILE}"

          echo "Downloading Node.js ${NODE_VERSION} for ${NODE_ARCH}..."
          curl -fsSL "$URL" -o "/tmp/${ZIPFILE}"

          echo "Verifying SHA256 checksum..."
          curl -fsSL "https://nodejs.org/dist/${NODE_VERSION}/SHASUMS256.txt" -o "/tmp/SHASUMS256.txt"
          (cd /tmp && grep "${ZIPFILE}" SHASUMS256.txt | sha256sum -c -)

          echo "Extracting node.exe..."
          unzip -j "/tmp/${ZIPFILE}" "node-${NODE_VERSION}-${NODE_ARCH}/node.exe" -d "${DEST}/"

          # Verify the binary works
          "${DEST}/node.exe" --version

          # Cleanup
          rm -f "/tmp/${ZIPFILE}"

      - name: Build Tauri app (macOS)
        if: matrix.os == 'macos-latest'
        working-directory: app
        run: npx tauri build --bundles app

      - name: Build Tauri app (Windows)
        if: matrix.os == 'windows-latest'
        working-directory: app
        run: npx tauri build --no-bundle

      - name: Package macOS release
        if: matrix.os == 'macos-latest'
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
        run: |
          STAGE="SkillBuilder-v${VERSION}-macos"
          mkdir -p "$STAGE"
          cp -R "app/src-tauri/target/release/bundle/macos/Skill Builder.app" "$STAGE/"
          cat > "$STAGE/run.sh" << 'SCRIPT'
          #!/bin/bash
          DIR="$(cd "$(dirname "$0")" && pwd)"
          xattr -cr "$DIR/Skill Builder.app"
          open -n "$DIR/Skill Builder.app"
          SCRIPT
          chmod +x "$STAGE/run.sh"
          zip -r "${STAGE}.zip" "$STAGE"

      - name: Package Windows release
        if: matrix.os == 'windows-latest'
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
        run: |
          STAGE="SkillBuilder-v${VERSION}-windows"
          mkdir -p "$STAGE"
          cp "app/src-tauri/target/release/skill-builder.exe" "$STAGE/"

          # Copy sidecar JS files (bootstrap + agent-runner + SDK)
          # The Rust exe-relative fallback looks for {exe_dir}/sidecar/dist/...
          mkdir -p "$STAGE/sidecar/dist/sdk"
          cp "app/sidecar/dist/package.json" "$STAGE/sidecar/dist/"
          cp "app/sidecar/dist/bootstrap.js" "$STAGE/sidecar/dist/"
          cp "app/sidecar/dist/agent-runner.js" "$STAGE/sidecar/dist/"
          cp "app/sidecar/dist/sdk/cli.js" "$STAGE/sidecar/dist/sdk/"
          cp "app/sidecar/dist/sdk/manifest.json" "$STAGE/sidecar/dist/sdk/"
          cp app/sidecar/dist/sdk/*.wasm "$STAGE/sidecar/dist/sdk/" 2>/dev/null || true
          if [ -d "app/sidecar/dist/sdk/vendor" ]; then
            cp -r "app/sidecar/dist/sdk/vendor" "$STAGE/sidecar/dist/sdk/"
          fi

          # Copy bundled Node.js binary
          # The Rust exe-relative fallback looks for {exe_dir}/resources/node/{arch}/bin/node.exe
          if [ -d "app/src-tauri/resources/node" ]; then
            mkdir -p "$STAGE/resources"
            cp -r "app/src-tauri/resources/node" "$STAGE/resources/node"
          fi

          # Copy agents and references (used by the sidecar at runtime)
          if [ -d "agents" ]; then
            cp -r "agents" "$STAGE/agents"
          fi
          if [ -d "references" ]; then
            cp -r "references" "$STAGE/references"
          fi

          7z a "${STAGE}.zip" "$STAGE"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: SkillBuilder-v*.zip

  package-plugins:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build plugin references
        run: ./scripts/build-plugin-skill.sh

      - name: Assemble plugin artifact
        shell: bash
        env:
          VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail
          STAGE="SkillBuilder-plugins-v${VERSION}"
          MP="${STAGE}/plugins"

          # --- skill-builder (coordinator + agents) ---
          mkdir -p "$MP/skill-builder/.claude-plugin" "$MP/skill-builder/skills" "$MP/skill-builder/agents"
          printf '{"name":"skill-builder","version":"%s","description":"Multi-agent workflow for creating domain-specific Claude skills","skills":"./skills/"}' "$VERSION" \
            > "$MP/skill-builder/.claude-plugin/plugin.json"
          cp -R skills/building-skills "$MP/skill-builder/skills/"
          cp agents/*.md "$MP/skill-builder/agents/"

          # --- skill-builder-research ---
          mkdir -p "$MP/skill-builder-research/.claude-plugin" "$MP/skill-builder-research/skills"
          printf '{"name":"skill-builder-research","version":"%s","description":"Research skill for dimension scoring and parallel research","skills":"./skills/"}' "$VERSION" \
            > "$MP/skill-builder-research/.claude-plugin/plugin.json"
          cp -R skills/research "$MP/skill-builder-research/skills/"

          # --- skill-builder-validate ---
          mkdir -p "$MP/skill-builder-validate/.claude-plugin" "$MP/skill-builder-validate/skills"
          printf '{"name":"skill-builder-validate","version":"%s","description":"Validate skill for quality checking and companion recommendations","skills":"./skills/"}' "$VERSION" \
            > "$MP/skill-builder-validate/.claude-plugin/plugin.json"
          cp -R skills/validate-skill "$MP/skill-builder-validate/skills/"

          # --- skill-builder-practices ---
          mkdir -p "$MP/skill-builder-practices/.claude-plugin" "$MP/skill-builder-practices/skills"
          printf '{"name":"skill-builder-practices","version":"%s","description":"Content guidelines and patterns for skill structure","skills":"./skills/"}' "$VERSION" \
            > "$MP/skill-builder-practices/.claude-plugin/plugin.json"
          cp -R skills/skill-builder-practices "$MP/skill-builder-practices/skills/"

          # --- marketplace.json ---
          mkdir -p "${STAGE}/.claude-plugin"
          printf '%s\n' \
            '{' \
            '  "name": "skills",' \
            '  "owner": { "name": "hbanerjee74" },' \
            '  "metadata": { "pluginRoot": "./plugins" },' \
            '  "plugins": [' \
            '    { "name": "skill-builder",           "source": "./plugins/skill-builder" },' \
            '    { "name": "skill-builder-research",  "source": "./plugins/skill-builder-research" },' \
            '    { "name": "skill-builder-validate",  "source": "./plugins/skill-builder-validate" },' \
            '    { "name": "skill-builder-practices", "source": "./plugins/skill-builder-practices" }' \
            '  ]' \
            '}' \
            > "${STAGE}/.claude-plugin/marketplace.json"

          zip -r "${STAGE}.zip" "$STAGE"

      - name: Upload plugin artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-plugins
          path: SkillBuilder-plugins-v*.zip

  release:
    runs-on: ubuntu-latest
    needs: [build, package-plugins]
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Generate release notes
        id: notes
        shell: bash
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          RELEASE_VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail

          # Tags are already available from checkout (fetch-depth: 0)

          # Determine the previous tag (most recent tag before the current one)
          PREVIOUS_TAG=$(git tag --sort=-creatordate | grep '^v' | head -2 | tail -1)

          # Build the commit log (use HEAD since the release tag doesn't exist yet)
          if [ -z "$PREVIOUS_TAG" ]; then
            # No previous tag — use all commits
            COMMITS=$(git log --oneline --format="%s" HEAD)
          else
            COMMITS=$(git log --oneline --format="%s" "${PREVIOUS_TAG}..HEAD")
          fi

          if [ -z "$COMMITS" ]; then
            COMMITS="No commits found for this release."
          fi

          # Build a simple bullet-list fallback from commit subjects
          FALLBACK=$(echo "$COMMITS" | sed 's/^/- /')

          NOTES=""

          # Attempt AI-generated release notes
          if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
            # Build the JSON payload safely with jq env vars (avoids shell expansion issues
            # when commit messages contain quotes, backticks, or dollar signs)
            export COMMITS
            PAYLOAD=$(jq -n '{
                model: "claude-haiku-4-5-20251001",
                max_tokens: 1024,
                messages: [{
                  role: "user",
                  content: ("You are writing release notes for Skill Builder v" + env.RELEASE_VERSION + ", a desktop app for building AI skills.\n\nSummarize the git commits below into polished, user-facing release notes.\n\nFormat:\n1. Start with 1-2 sentences highlighting the most notable change(s)\n2. Then group changes under these markdown headings (omit any with no items):\n   ### Highlights\n   ### New\n   ### Improved\n   ### Fixed\n\nOnly add a ### Breaking Changes section if there are changes that require user action.\n\nWriting style:\n- Write for end users, not developers\n- Keep each bullet to one concise sentence\n- Describe what changed from the user perspective, not the code perspective\n- No commit hashes, file paths, PR numbers, or technical jargon\n- If multiple commits relate to the same user-facing change, combine them into one bullet\n\nCommits:\n" + env.COMMITS)
                }]
              }')

            RESPONSE=$(curl -s --max-time 60 \
              -H "x-api-key: ${ANTHROPIC_API_KEY}" \
              -H "anthropic-version: 2023-06-01" \
              -H "content-type: application/json" \
              -d "$PAYLOAD" \
              "https://api.anthropic.com/v1/messages" 2>/dev/null) || true

            if [ -n "${RESPONSE:-}" ]; then
              NOTES=$(echo "$RESPONSE" | jq -r '.content[0].text // empty' 2>/dev/null) || true
            fi
          fi

          # Fall back to simple commit list if AI summary is empty
          if [ -z "${NOTES:-}" ]; then
            NOTES=$(printf "### What's Changed\n\n%s" "$FALLBACK")
          fi

          # Write multiline output
          echo "release_notes<<EOF" >> "$GITHUB_OUTPUT"
          echo "$NOTES" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ github.event.inputs.version }}
          name: Skill Builder v${{ github.event.inputs.version }}
          body: ${{ steps.notes.outputs.release_notes }}
          files: artifacts/**/*.zip
